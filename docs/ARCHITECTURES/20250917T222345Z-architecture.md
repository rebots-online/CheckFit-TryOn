# CheckFit Try-On Architecture & Roadmap (2025-09-17T22:23:45Z)

## Repository Identity
- **Project**: CheckFit Try-On
- **UUIDv8**: `cfit-tryon-2025a` (assigned for cross-project graph alignment)
- **Purpose**: Client-side virtual try-on experience leveraging Google Gemini image generation APIs.

## Current AST Abstraction (High-Level)
```
CheckFit-TryOn
├── App.tsx
│   ├── components/StartScreen
│   │   ├── hooks: React state, FileReader
│   │   ├── services/geminiService.generateModelImage
│   │   └── components/ui/compare (drag slider)
│   ├── components/Canvas
│   │   ├── state: pose carousel visibility
│   │   ├── components/Spinner
│   │   ├── components/icons {RotateCcwIcon, ChevronLeftIcon, ChevronRightIcon}
│   │   └── uses props from App for pose + loading state
│   ├── components/WardrobeModal (WardrobePanel)
│   │   ├── helpers: urlToFile (HTMLCanvas)
│   │   ├── components/icons {UploadCloudIcon, CheckCircleIcon}
│   │   └── interacts via App.handleGarmentSelect
│   ├── components/OutfitStack
│   │   └── components/icons.Trash2Icon
│   ├── components/Footer
│   │   └── rotating suggestions list (setInterval)
│   ├── components/Spinner
│   ├── services/geminiService
│   │   ├── GoogleGenAI SDK
│   │   ├── generateModelImage(File)
│   │   ├── generateVirtualTryOnImage(modelUrl, File)
│   │   └── generatePoseVariation(tryOnUrl, poseInstruction)
│   ├── lib/utils
│   │   ├── cn(...classValues)
│   │   └── getFriendlyErrorMessage(error, context)
│   ├── types.ts {WardrobeItem, OutfitLayer}
│   └── wardrobe.ts defaultWardrobe[]
├── components/ui (shared UI primitives; e.g., Compare slider)
├── index.tsx (React root bootstrap)
├── index.css / tailwind styles (implicit via build)
├── vite.config.ts (build tooling)
└── package.json (deps: React, Framer Motion, Google GenAI, Tailwind utilities)
```

## Component Interaction Narrative
1. **StartScreen** captures a user photo, requests `generateModelImage`, and returns a data URL for the generated model.
2. **App** seeds `outfitHistory` with the base model layer and toggles between **StartScreen** and dressing room layout.
3. **Canvas** displays the active pose image, handles pose cycling, and surfaces loader overlays.
4. **WardrobePanel** presents default and user-uploaded garments, converts selection URLs into `File` objects, and calls `handleGarmentSelect`.
5. **App** invokes `generateVirtualTryOnImage` to append new outfit layers, manages undo/redo semantics via `outfitHistory` slicing, and lazily generates pose variations through `generatePoseVariation`.
6. **OutfitStack** summarizes layers with deletion on latest garment, while **Footer** cycles remix prompts.

## Identified Gaps & Opportunities
- **State & Data Management**: Lacks global store (e.g., Zustand/Recoil) for future multi-scene expansions.
- **Error Observability**: Console logging minimal; would benefit from telemetry hooks.
- **Offline & Cache Strategy**: No persistence for generated outfits or wardrobe assets.
- **Billing & Access Control**: No gating mechanism for API usage or monetization tiers.
- **UI/UX polish**: Canvas overlay and wardrobe grid are functional but could leverage richer art direction, transitions, and theming.

## Proposed Extensions (to inform checklist & future coding)
### 1. Documentation & Knowledge Graph Sync
- Generate architecture & checklist assets (this task) with alignment instructions for future agents.
- Update README with architecture summary, roadmap, and UX/billing commentary.

### 2. Visual Experience Enhancements
- Introduce a `design-system` folder housing tokens (colors, typography, spacing) and components (GlassCard, MotionButton).
- Implement `components/Hero.tsx`, `components/SceneBackground.tsx`, and dynamic gradients to enhance the dressing room.
- Add GPU-friendly post-processing (e.g., WebGL filters) as optional modules for hero imagery.

### 3. Billing Platform Integration Layer
- Create `services/billing/` namespace with:
  - `BillingProvider.ts` interface describing subscription, entitlement, and pack-purchase APIs.
  - `revenueCatClient.ts` wrapping RevenueCat REST API with SKU pack logic.
  - `albyLightningClient.ts` interfacing with Alby Hub/BTC Pay for Lightning microtransactions.
  - `billingOrchestrator.ts` for runtime provider selection and entitlement caching.
- Shared React hook `hooks/useBilling.ts` to expose entitlements, purchase flows, and loading/error state to UI.
- UI entry points: `components/billing/BillingPortalButton.tsx`, `components/billing/EntitlementGate.tsx` to guard premium functionality (e.g., higher-res outputs or advanced wardrobe slots).

### 4. Roadmap for Completion
1. **Foundations**: Document architecture (current task), align README, and create backlog.
2. **Design System**: Build theming + animation primitives.
3. **Billing Integration**: Implement connectors, universal pack configuration, fallback to Lightning module.
4. **Experience Elevation**: Expand wardrobe management, add share/export flows, integrate social components.
5. **Observability & QA**: Add analytics, error boundary components, storybook/regression tests.
6. **Deployment**: Provide CI/CD pipeline, environment configuration for API keys and billing providers.

### 5. Universal MicrosaaS Pack Specification (Draft)
- **Product Model**: `MicrosaasPack { id, name, description, priceUSD, priceSats, entitlements[], recurring?: boolean }`
- **Entitlement Types**: `try_on_slots`, `pose_variations`, `hi_res_exports`, `priority_queue`.
- **Billing Providers**:
  - **RevenueCat**: Map `MicrosaasPack` to RC products/offerings; rely on RevenueCat webhook to update entitlements.
  - **AlbyHub/BTC Pay**: Accept Lightning invoices; confirm payment via webhook; issue JWT-based entitlement tokens.
- **Connector Requirements**:
  - Provider-agnostic interface exposing `fetchPacks`, `purchasePack`, `syncEntitlements`, `restorePurchases`.
  - Webhook handler scaffolding for both providers.
  - Local caching & optimistic UI patterns for React clients.

## Deliverables for Current Task
1. Record this architecture snapshot (text + UML + Mermaid).
2. Publish execution checklist for documentation updates.
3. Update README with architecture summary, commentary, and roadmap.
4. Ensure diagrams, checklist, and README capture RevenueCat/Lightning billing vision.

> **Note**: Hybrid knowledge graph / Neo4j sync is not accessible within this environment; document manually for later ingestion.
